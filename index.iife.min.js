var simplifySvgPath=(function(){class t{constructor(t){this.precision=t,this.multiplier=Math.pow(10,this.precision)}number(t){return this.precision<16?Math.round(t*this.multiplier)/this.multiplier:t}pair(t,e){return this.number(t)+","+this.number(e)}}class e{constructor(t,e){this.x=t,this.y=e}negate(){return new e(-this.x,-this.y)}normalize(t=1){return this.multiply(t/(this.getLength()||1/0))}add(t){return new e(this.x+t.x,this.y+t.y)}subtract(t){return new e(this.x-t.x,this.y-t.y)}multiply(t){return new e(this.x*t,this.y*t)}dot(t){return this.x*t.x+this.y*t.y}getLength(){return Math.sqrt(this.x*this.x+this.y*this.y)}getDistance(t){const e=this.x-t.x,r=this.y-t.y;return Math.sqrt(e*e+r*r)}}class r{constructor(t,e){this.point=t,this.handleIn=e}setHandleOut(t){this.handleOut=t}}class i{constructor(t,e){this.points=t,this.closed=e}fit(t){const e=this.points;this.closed&&(e.unshift(e[e.length-1]),e.push(e[1]));const i=e.length;if(0===i)return[];const s=[new r(e[0])];return this.fitCubic(s,t,0,i-1,e[1].subtract(e[0]),e[i-2].subtract(e[i-1])),this.closed&&(s.shift(),s.pop()),s}fitCubic(t,e,r,i,s,n){const o=this.points;if(i-r==1){const e=o[r],a=o[i],h=e.getDistance(a)/3;return void this.addCurve(t,[e,e.add(s.normalize(h)),a.add(n.normalize(h)),a])}const a=this.chordLengthParameterize(r,i);let h,l=Math.max(e,e*e),u=!0;for(let o=0;o<=4;o++){const o=this.generateBezier(r,i,a,s,n),c=this.findMaxError(r,i,o,a);if(c.error<e&&u)return void this.addCurve(t,o);if(h=c.index,c.error>=l)break;u=this.reparameterize(r,i,a,o),l=c.error}const c=o[h-1].subtract(o[h+1]);this.fitCubic(t,e,r,h,s,c),this.fitCubic(t,e,h,i,c.negate(),n)}addCurve(t,e){t[t.length-1].setHandleOut(e[1].subtract(e[0])),t.push(new r(e[3],e[2].subtract(e[3])))}generateBezier(t,e,r,i,s){const n=1e-12,o=Math.abs,a=this.points,h=a[t],l=a[e],u=[[0,0],[0,0]],c=[0,0];for(let n=0,o=e-t+1;n<o;n++){const e=r[n],o=1-e,d=3*e*o,p=o*o*o,f=d*o,m=d*e,y=e*e*e,b=i.normalize(f),x=s.normalize(m),g=a[t+n].subtract(h.multiply(p+f)).subtract(l.multiply(m+y));u[0][0]+=b.dot(b),u[0][1]+=b.dot(x),u[1][0]=u[0][1],u[1][1]+=x.dot(x),c[0]+=b.dot(g),c[1]+=x.dot(g)}const d=u[0][0]*u[1][1]-u[1][0]*u[0][1];let p,f;if(o(d)>n){const t=u[0][0]*c[1]-u[1][0]*c[0];p=(c[0]*u[1][1]-c[1]*u[0][1])/d,f=t/d}else{const t=u[0][0]+u[0][1],e=u[1][0]+u[1][1];p=f=o(t)>n?c[0]/t:o(e)>n?c[1]/e:0}const m=l.getDistance(h),y=n*m;let b,x;if(p<y||f<y)p=f=m/3;else{const t=l.subtract(h);b=i.normalize(p),x=s.normalize(f),b.dot(t)-x.dot(t)>m*m&&(p=f=m/3,b=x=null)}return[h,h.add(b||i.normalize(p)),l.add(x||s.normalize(f)),l]}reparameterize(t,e,r,i){for(let s=t;s<=e;s++)r[s-t]=this.findRoot(i,this.points[s],r[s-t]);for(let t=1,e=r.length;t<e;t++)if(r[t]<=r[t-1])return!1;return!0}findRoot(t,e,r){const i=[],s=[];for(let e=0;e<=2;e++)i[e]=t[e+1].subtract(t[e]).multiply(3);for(let t=0;t<=1;t++)s[t]=i[t+1].subtract(i[t]).multiply(2);const n=this.evaluate(3,t,r),o=this.evaluate(2,i,r),a=this.evaluate(1,s,r),h=n.subtract(e),l=o.dot(o)+h.dot(a);return(u=l)>=-112e-18&&u<=112e-18?r:r-h.dot(o)/l;var u}evaluate(t,e,r){const i=e.slice();for(let e=1;e<=t;e++)for(let s=0;s<=t-e;s++)i[s]=i[s].multiply(1-r).add(i[s+1].multiply(r));return i[0]}chordLengthParameterize(t,e){const r=[0];for(let i=t+1;i<=e;i++)r[i-t]=r[i-t-1]+this.points[i].getDistance(this.points[i-1]);for(let i=1,s=e-t;i<=s;i++)r[i]/=r[s];return r}findMaxError(t,e,r,i){let s=Math.floor((e-t+1)/2),n=0;for(let o=t+1;o<e;o++){const e=this.evaluate(3,r,i[o-t]).subtract(this.points[o]),a=e.x*e.x+e.y*e.y;a>=n&&(n=a,s=o)}return{error:n,index:s}}}return(r,s={})=>((e,r,i)=>{const s=e.length,n=new t(i);let o,a,h,l,u=!0;const c=[],d=(t,e)=>{const r=t.point.x,i=t.point.y;if(u)c.push("M"+n.pair(r,i)),u=!1;else{const s=r+(t.handleIn?.x??0),u=i+(t.handleIn?.y??0);if(s===r&&u===i&&h===o&&l===a){if(!e){const t=r-o,e=i-a;c.push(0===t?"v"+n.number(e):0===e?"h"+n.number(t):"l"+n.pair(t,e))}}else c.push("c"+n.pair(h-o,l-a)+" "+n.pair(s-o,u-a)+" "+n.pair(r-o,i-a))}o=r,a=i,h=r+(t.handleOut?.x??0),l=i+(t.handleOut?.y??0)};if(!s)return"";for(let t=0;t<s;t++)d(e[t]);return r&&s>0&&(d(e[0],!0),c.push("z")),c.join("")})(new i(r.map(t=>new e(t[0],t[1])),s.closed).fit(s.tolerance??2.5),s.closed,s.precision??5);})()